<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Reduce</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Reduce.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Reduce.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">reducerabinpairs-0.1.0.0: reduce the acceptance condition of a Rabin automaton</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Clara Waldmann, 2016</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Reduce</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Reductions Independent of the Transition System</a></li><li><a href="#g:2">Reductions Dependent of the Transition System</a></li><li><a href="#g:3">Splitting and Combinig Pairs</a></li><li><a href="#g:4">Checks</a></li><li><a href="#g:5">Conversion Between DRA and Singleton DRA</a></li><li><a href="#g:6">Example Rabin Automata</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Reductions of a Rabin acceptance condition dependent and independent of the transition system of the automaton.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:set_reduce">set_reduce</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:set_sat">set_sat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:set_irredundant">set_irredundant</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><span class="keyword">data</span> <a href="#t:SingletonRabinpair">SingletonRabinpair</a> q = <a href="#v:SingletonRabinpair">SingletonRabinpair</a> {<ul class="subs"><li><a href="#v:infinite">infinite</a> :: q</li><li><a href="#v:finite">finite</a> :: <a href="http://hackage.haskell.org/packages/archive/containers/0.5.6.2/doc/html/Data-Set.html#t:Set">Set</a> q</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:SingletonDRA">SingletonDRA</a> q a l = <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q]</li><li class="src short"><a href="#v:top_reduce">top_reduce</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:top_sat">top_sat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:top_irredundant">top_irredundant</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q]</li><li class="src short"><a href="#v:set_split">set_split</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l</li><li class="src short"><a href="#v:set_combine">set_combine</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:top_split">top_split</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:top_combine">top_combine</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:is_compact">is_compact</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_scc">is_scc</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:toSDRA">toSDRA</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Text-Show.html#t:Show">Show</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l</li><li class="src short"><a href="#v:toDRA">toDRA</a> :: <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l</li><li class="src short"><a href="#v:exdra">exdra</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () ()</li><li class="src short"><a href="#v:exdra1">exdra1</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () ()</li><li class="src short"><a href="#v:exdra2">exdra2</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () ()</li></ul></div><div id="interface"><h1 id="g:1">Reductions Independent of the Transition System</h1><div class="top"><p class="src"><a name="v:set_reduce" class="def">set_reduce</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#set_reduce" class="link">Source</a></p><div class="doc"><p>reduction of a pair by (E,F) -&gt; (E, F \ E) </p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept $ set_reduce exdra
</code></strong>[(fromList [3],fromList [1,2])
,(fromList [1,2,3],fromList [])
,(fromList [],fromList [1,2])
]
</pre></div></div><div class="top"><p class="src"><a name="v:set_sat" class="def">set_sat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#set_sat" class="link">Source</a></p><div class="doc"><p>remove unsatisfiable pairs (where the final set is empty)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept  $ set_sat $ set_reduce exdra
</code></strong>[(fromList [3],fromList [1,2]),(fromList [],fromList [1,2])]
</pre></div></div><div class="top"><p class="src"><a name="v:set_irredundant" class="def">set_irredundant</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#set_irredundant" class="link">Source</a></p><div class="doc"><p>remove redundant pairs</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept $ set_irredundant $ set_sat $ set_reduce exdra
</code></strong>[(fromList [],fromList [1,2])]
</pre></div></div><h1 id="g:2">Reductions Dependent of the Transition System</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:SingletonRabinpair" class="def">SingletonRabinpair</a> q <a href="src/Reduce.html#SingletonRabinpair" class="link">Source</a></p><div class="doc"><p>type for a Rabin pair whose final set is singleton</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SingletonRabinpair" class="def">SingletonRabinpair</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:infinite" class="def">infinite</a> :: q</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:finite" class="def">finite</a> :: <a href="http://hackage.haskell.org/packages/archive/containers/0.5.6.2/doc/html/Data-Set.html#t:Set">Set</a> q</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:SingletonRabinpair" class="caption collapser" onclick="toggleSection('i:SingletonRabinpair')">Instances</p><div id="section.i:SingletonRabinpair" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q)</span> <a href="src/Reduce.html#line-51" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q)</span> <a href="src/Reduce.html#line-51" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Text-Show.html#t:Show">Show</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q)</span> <a href="src/Reduce.html#line-51" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:SingletonDRA" class="def">SingletonDRA</a> q a l = <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q] <a href="src/Reduce.html#SingletonDRA" class="link">Source</a></p><div class="doc"><p>type for Rabin automata where each final set is singleton</p></div></div><div class="top"><p class="src"><a name="v:top_reduce" class="def">top_reduce</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#top_reduce" class="link">Source</a></p><div class="doc"><p>reduce a pair (Rabin automaton has to be compact)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept$ top_reduce $ exdra2 {accept = [(S.fromList [3],S.fromList [1]),(S.fromList [3],S.fromList [2])]}
</code></strong>[(fromList [],fromList [1]),(fromList [],fromList [2])]
</pre></div></div><div class="top"><p class="src"><a name="v:top_sat" class="def">top_sat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#top_sat" class="link">Source</a></p><div class="doc"><p>remove unsatisfiable pairs (Rabin automaton has to be compact)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept $ top_sat $ toDRA $ set_split exdra1
</code></strong>[(fromList [2],fromList [1])
,(fromList [3],fromList [2])
,(fromList [1],fromList [2])]
</pre></div></div><div class="top"><p class="src"><a name="v:top_irredundant" class="def">top_irredundant</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q a l [<a href="Reduce.html#t:SingletonRabinpair">SingletonRabinpair</a> q] <a href="src/Reduce.html#top_irredundant" class="link">Source</a></p><div class="doc"><p>remove redundant pairs
top_irredundant :: (Ord q, Eq l, Ord a) =&gt; SingletonDRA q a l -&gt; SingletonDRA q a l</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>accept $ top_irredundant $ toSDRA $ top_sat $ toDRA $ set_split exdra1
</code></strong>[SingletonRabinpair {infinite = 1, finite = fromList [2]}
,SingletonRabinpair {infinite = 2, finite = fromList [3]}]
</pre></div></div><h1 id="g:3">Splitting and Combinig Pairs</h1><div class="top"><p class="src"><a name="v:set_split" class="def">set_split</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l <a href="src/Reduce.html#set_split" class="link">Source</a></p><div class="doc"><p>split final sets into singletons</p></div></div><div class="top"><p class="src"><a name="v:set_combine" class="def">set_combine</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#set_combine" class="link">Source</a></p><div class="doc"><p>combine pair with same excluded set by taking the union of the final sets</p></div></div><div class="top"><p class="src"><a name="v:top_split" class="def">top_split</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#top_split" class="link">Source</a></p><div class="doc"><p>split pairs to become compact</p></div></div><div class="top"><p class="src"><a name="v:top_combine" class="def">top_combine</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#top_combine" class="link">Source</a></p><div class="doc"><p>combine pairs in different SCCs (only for strongly compact Rabin automata)</p></div></div><h1 id="g:4">Checks</h1><div class="top"><p class="src"><a name="v:is_compact" class="def">is_compact</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="src/Reduce.html#is_compact" class="link">Source</a></p><div class="doc"><p>is the Rabin automaton compact? (final sets contained in one SCC)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>is_compact exdra2
</code></strong>False
</pre></div></div><div class="top"><p class="src"><a name="v:is_scc" class="def">is_scc</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="src/Reduce.html#is_scc" class="link">Source</a></p><div class="doc"><p>is the Rabin automaton strongly compact? (each pair contained in one SCC)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>is_scc  exdra1
</code></strong>True
</pre></div></div><h1 id="g:5">Conversion Between DRA and Singleton DRA</h1><div class="top"><p class="src"><a name="v:toSDRA" class="def">toSDRA</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Text-Show.html#t:Show">Show</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l -&gt; <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l <a href="src/Reduce.html#toSDRA" class="link">Source</a></p><div class="doc"><p>only works for automata where all final sets are singletons</p></div></div><div class="top"><p class="src"><a name="v:toDRA" class="def">toDRA</a> :: <a href="Reduce.html#t:SingletonDRA">SingletonDRA</a> q a l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q a l <a href="src/Reduce.html#toDRA" class="link">Source</a></p></div><h1 id="g:6">Example Rabin Automata</h1><div class="top"><p class="src"><a name="v:exdra" class="def">exdra</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () () <a href="src/Reduce.html#exdra" class="link">Source</a></p><div class="doc"><p>Example Rabin automaton (acceptance condition from Example 6.6 in the thesis)</p><pre> exdra = makeAutomat 
    [(1,()), (2,()), (3,())] 
    [(1,(),1), (1,(),2), (2,(),1), (2,(),2), (1,(),3), (3,(),2)] 
    [1] 
    [ (S.fromList [3], S.fromList [1,2])
    , (S.fromList [1,2,3], S.fromList [2])
    , (S.fromList [], S.fromList [1,2])
    ]
</pre></div></div><div class="top"><p class="src"><a name="v:exdra1" class="def">exdra1</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () () <a href="src/Reduce.html#exdra1" class="link">Source</a></p><div class="doc"><p>Example Rabin automaton (acceptance condition taken from Example 6.13 in the thesis)</p><pre> exdra1 = makeAutomat 
    [(1,()), (2,()), (3,())] 
    [(1,(),1), (1,(),2), (2,(),1), (2,(),2), (1,(),3), (3,(),2)] 
    [1] 
    [ (S.fromList [2], S.fromList [1])
    , (S.fromList [3], S.fromList [2])
    , (S.fromList [1], S.fromList [2,3])
    ]
</pre></div></div><div class="top"><p class="src"><a name="v:exdra2" class="def">exdra2</a> :: <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.0.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a> () () <a href="src/Reduce.html#exdra2" class="link">Source</a></p><div class="doc"><p>example Rabin automaton (from Example 6.18 in the thesis)</p><pre> exdra2 = makeAutomat
    [(1,()), (2,()), (3,())]
    [(1,(),1), (1,(),2), (2,(),2), (1,(),3), (3,(),2)]
    [1]
    [(S.fromList [3], S.fromList [1,2])]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>